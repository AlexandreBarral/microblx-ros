/*
 * myblock microblx function block (autogenerated, don't edit)
 */

#include <ubx/ubx.h>
#include <kdlubx/kdl.h>
#include <ros/ros.h>

/* block meta information */
char ubxros_meta[] =
    " { doc='A mixed port geometry_msg/Vector3' block,"
    "   realtime=false,"
    "}";

/* declaration of block configuration */
ubx_config_t ubxros_config[] = {
    { .name="topic_out", .type_name = "char" },
    { .name="topic_in", .type_name = "char" },
    { 0 },
};

/* declaration port block ports */
ubx_port_t ubxros_ports[] = {
    { .name="pos_out", .doc="out pos", .out_type_name="double" },
    { .name="pos_in", .doc="in pos", .in_type_name="double" },
    { 0 },
};

/* instance state */
struct ubxros_info
{
    /* cached ports */
    struct
    {
        ubx_port_t *pos;
    };
};

/* init */
int ubxros_init(ubx_block_t *b)
{
    int ret = -1;
    long len;

    struct ubxros_info *inf;
    const char *topic;

    /* allocate memory for the block local state */
    inf = static_cast<ubxros_info*>(calloc(1, sizeof(struct ubxros_info)));

    if (inf == NULL) {
        ubx_err(b, "myblock: failed to alloc memory");
        ret = EOUTOFMEM;
        goto out;
    }

    b->private_data = inf;

    /* config topic */
    len = cfg_getptr_char(b, "topic", &topic);

    if (len < 0) {
        ubx_err(b, "failed to retrive cfg 'topic'");
        goto out_free;
    } else if (len == 0) {
        ubx_err(b, "mandatory config 'topic' unset");
        goto out_free;
    }

    /* need to create node? */
    if (!ros::isInitialized()) {
        ubx_info(b, "initializing ROS node");
        int argc = 0;
        char** argv = NULL;
        ros::init(argc, argv, b->ni->name, ros::init_options::AnonymousName);

        /* start the node */
        ros::start();
    }

    /* ensure a ROS master is running */
    if (!ros::master::check()) {
        ubx_err(b, "no ROS master found");
        goto out_free;
    }

    /* subscribe */

    /* cache ports */
    inf->pos = ubx_port_get(b, "pos");

    /* all good */
    ret=0;
    goto out;

out_free:
    delete(inf);
out:
    return ret;
}

/* start */
int ubxros_start(ubx_block_t *b)
{
    int ret = -1;
    // struct ubxros_info *inf = (struct ubxros_info*) b->private_data;

    if (!ros::ok()) {
        ubx_err(b, "ROS node not initialized or shutting down");
        goto out;
    }

    /* OK */
    ret = 0;
out:
    return ret;
}

/* stop */
void ubxros_stop(ubx_block_t *b)
{
    /* struct ubxros_info *inf = (struct ubxros_info*) b->private_data; */
    ubx_info(b, "%s", __FUNCTION__);
}

/* cleanup */
void ubxros_cleanup(ubx_block_t *b)
{
    /* struct ubxros_info *inf = (struct ubxros_info*) b->private_data; */
    ubx_info(b, "%s", __FUNCTION__);
    free(b->private_data);
}

/* step */
void ubxros_step(ubx_block_t *b)
{
    /* struct ubxros_info *inf = (struct ubxros_info*) b->private_data; */
    ubx_info(b, "%s", __FUNCTION__);
}

/* put everything together */
ubx_block_t ubxros_block = {
    .name = "myblock",
    .meta_data = ubxros_meta,
    .type = BLOCK_TYPE_COMPUTATION,

    .ports = ubxros_ports,
    .configs = ubxros_config,

    /* ops */
    .init = ubxros_init,
    .start = ubxros_start,
    .stop = ubxros_stop,
    .cleanup = ubxros_cleanup,
    .step = ubxros_step,
};



/* myblock module init and cleanup functions */
int ubxros_mod_init(ubx_node_info_t* ni)
{
    return ubx_block_register(ni, &ubxros_block);
}

void ubxros_mod_cleanup(ubx_node_info_t *ni)
{
    ubx_block_unregister(ni, "myblock");
}

UBX_MODULE_INIT(ubxros_mod_init)
UBX_MODULE_CLEANUP(ubxros_mod_cleanup)
UBX_MODULE_LICENSE_SPDX(MIT)
